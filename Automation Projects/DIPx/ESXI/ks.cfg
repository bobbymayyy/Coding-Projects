# Kickstart to deploy ESXi from DIPx automatically

vmaccepteula
rootpw VMware!23!

# Install to the first local disk, wipe existing VMFS
install --firstdisk=local --overwritevmfs

# Management network
network --bootproto=static --ip=10.0.99.2 --netmask=255.255.255.0 --gateway=10.0.99.1 --nameserver=10.0.20.10 --hostname=esxi01.nerd.dipx

reboot

%firstboot --interpreter=busybox

# ---------- VARIABLES ----------
VOL_BASE="/vmfs/volumes"
REPO_LABEL="REPO"
REPO_BASE="${VOL_BASE}/${REPO_LABEL}"
DS_LABEL="datastore1"
DS_BASE="${VOL_BASE}/${DS_LABEL}"
VM_NAME="prov01"
PG_MGT="VLAN99-Mgmt" # controller NIC
VM_DIR="${DS_BASE}/vms/${VM_NAME}"
PROV_ISO="${REPO_BASE}/isos/OL10-prov.iso" # your single ISO w/ embedded KS

# ---------- LIL HELPERS ----------
log(){ echo "KS[$(date +%H:%M:%S)] $*"; }

find_usb_dev() {
  # Parse esxcli output by device blocks; pick first local USB disk that's not a CD-ROM
  esxcli storage core device list | awk '
    BEGIN{dev=""; usb=0; cd=0}
    /^Device:/ { if (dev!="" && usb && !cd) { print dev; exit } dev=$2; usb=0; cd=0; next }
    /Is USB:[[:space:]]*true/ { usb=1; next }
    /Display Name: .*CD-ROM/ { cd=1; next }
    END { if (dev!="" && usb && !cd) print dev }
  '
}

find_usb_dev_fallback() {
  # Look under /dev/disks for mpx.vmhba* disks (exclude the virtual CD: vmhba64)
  for cand in $(ls /dev/disks/ 2>/dev/null | grep -E '^mpx\.vmhba[0-9]+:C0:T0:L0$' | sort); do
    case "$cand" in *vmhba64*) continue;; esac
    # confirm ESXi thinks this one is USB
    if esxcli storage core device list | awk -v d="$cand" '
         $0 ~ ("^Device: " d "$") {f=1}
         f && /Is USB:[[:space:]]*true/ {print "yes"; exit}
       ' | grep -q yes; then
      echo "$cand"
      return 0
    fi
  done
  return 1
}

mount_repo() {
  # Stop usb arbitrator so the host stack can use USB mass storage
  /etc/init.d/usbarbitrator stop >/dev/null 2>&1 || true

  # Quick success if already mounted
  if esxcli storage filesystem list | awk '{print $1}' | grep -qx "$REPO_LABEL"; then
    echo "Repo: ${REPO_LABEL} already mounted"
    return 0
  fi

  # Rescan HBAs so the device appears
  esxcli storage core adapter rescan --all >/dev/null 2>&1 || true

  # Try primary detector, then fallback
  USB_DEV="$(find_usb_dev)"
  [ -z "$USB_DEV" ] && USB_DEV="$(find_usb_dev_fallback || true)"

  if [ -z "$USB_DEV" ]; then
    echo "Repo: no USB device detected"
    return 1
  fi

  P2="/dev/disks/${USB_DEV}:2"
  if [ ! -e "$P2" ]; then
    echo "Repo: ${USB_DEV} has no :2 partition"
    return 1
  fi

  # If REPO already mounted by UUID but not labeled, try by device path
  if vmkfstools -P "$P2" >/dev/null 2>&1; then
    esxcli storage filesystem mount -d "$P2" >/dev/null 2>&1 || \
    esxcli storage filesystem mount -l "$REPO_LABEL"  >/dev/null 2>&1 || true
  else
    echo "Repo: ${P2} not VMFS (expected pre-formatted VMFS6)"
    return 1
  fi

  # Verify
  if esxcli storage filesystem list | awk '{print $1}' | grep -qx "$REPO_LABEL"; then
    echo "Repo: ${REPO_LABEL} mounted"
    return 0
  else
    echo "Repo: mount attempt failed"
    return 1
  fi
}

ensure_net(){
  # NTP/SSH (quality-of-life)
  esxcli system ntp set -s 10.0.20.10
  esxcli system ntp set -e true
  /etc/init.d/ntpd restart
  vim-cmd hostsvc/enable_ssh; vim-cmd hostsvc/start_ssh

  # vSwitch + Mgmt PG (idempotent)
  esxcli network vswitch standard add -v vSwitchLAN 2>/dev/null || true
  esxcli network vswitch standard portgroup add -v vSwitchLAN -p "$PG_MGT" 2>/dev/null || true
  esxcli network vswitch standard portgroup set -p "$PG_MGT" -v 99

  # Uplink if possible
  UPLINK="$(esxcli network nic list | awk '/(Up|Unknown)/{print $1; exit}')"
  if [ -n "$UPLINK" ]; then
    esxcli network vswitch standard uplink add -v vSwitchLAN -u "$UPLINK" >/dev/null 2>&1 || true
    log "Attached uplink $UPLINK to vSwitchLAN"
  else
    log "No physical uplink found; continuing without adding one."
  fi
}

vm_exists(){ vim-cmd vmsvc/getallvms | awk '{print $1,$2}' | grep -q " ${VM_NAME}$"; }

create_provisioner_vm(){
  [ -f "$PROV_ISO" ] || { log "Missing ISO: $PROV_ISO"; return 1; }

  mkdir -p "$VM_DIR"
  [ -f "${VM_DIR}/${VM_NAME}.vmdk" ] || vmkfstools -c 30G -d thin "${VM_DIR}/${VM_NAME}.vmdk"

  cat > "${VM_DIR}/${VM_NAME}.vmx" <<EOF
.encoding = "UTF-8"
config.version = "8"
virtualHW.version = "14"
displayName = "${VM_NAME}"
guestOS = "other3xLinux-64"
memsize = "4096"
numvcpus = "2"

scsi0.present = "TRUE"
scsi0.virtualDev = "lsilogic"
scsi0:0.present = "TRUE"
scsi0:0.fileName = "${VM_NAME}.vmdk"

ethernet0.present = "TRUE"
ethernet0.virtualDev = "vmxnet3"
ethernet0.networkName = "${PG_MGT}"
ethernet0.addressType = "generated"

sata0.present = "TRUE"
sata0:0.present = "TRUE"
sata0:0.deviceType = "cdrom-image"
sata0:0.fileName = "${PROV_ISO}"

bios.bootDeviceClasses = "allow:cdrom,hd,net,floppy"
EOF

  if ! vm_exists; then
    VMID=$(vim-cmd solo/registervm "${VM_DIR}/${VM_NAME}.vmx")
    log "Registered ${VM_NAME} as VMID ${VMID}"
  else
    VMID=$(vim-cmd vmsvc/getallvms | awk -v n="${VM_NAME}" '$0 ~ (" " n "$"){print $1}')
    vim-cmd vmsvc/reload "$VMID" >/dev/null 2>&1 || true
    log "${VM_NAME} already registered as VMID ${VMID}"
  fi

  vim-cmd vmsvc/power.on "$VMID" >/dev/null 2>&1 || true
  log "Powered on ${VM_NAME}"
}

# ---------- MAIN ----------
ensure_net
if mount_repo; then
  log "Repo ready at ${REPO_BASE}; creating provisioning VMâ€¦"
  create_provisioner_vm || log "Provisioner creation failed"
else
  log "Repo not available; skipping provisioning VM creation"
fi
# ---------- MAIN END ----------
