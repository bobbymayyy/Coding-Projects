# Kickstart to deploy ESXi 8 from DIPx automatically

vmaccepteula
rootpw VMware!23!

# Install to the first local disk, wipe existing VMFS
install --firstdisk=local --overwritevmfs

# Management network
network --bootproto=static --ip=10.0.99.2 --netmask=255.255.255.0 --gateway=10.0.99.1 --nameserver=10.0.20.10 --hostname=esxi01.nerd.dipx

reboot

%firstboot --interpreter=busybox

exec 1>/var/log/firstboot.out 2>&1
set -x   # optional: shell trace for deep debugging

# ---------- VARIABLES ----------
VOL_BASE="/vmfs/volumes"
REPO_LABEL="REPO"
REPO_BASE="${VOL_BASE}/${REPO_LABEL}"
DS_LABEL="datastore1"
DS_BASE="${VOL_BASE}/${DS_LABEL}"
VM_NAME="prov01"
PG_MGT="VLAN99-Mgmt" # controller NIC
VMS="${DS_BASE}/vms"
ISOS="${REPO_BASE}/images/isos"
VM_DIR="${VMS}/${VM_NAME}"
PROV_ISO="${ISOS}/OL10-prov.iso" # your single ISO w/ embedded KS

# ---------- LIL HELPERS ----------
log(){ echo "KS[$(date +%H:%M:%S)] $*"; }

mount_repo() {
  # already mounted?
  esxcli storage filesystem list | awk -v L="$REPO_LABEL" '$2==L{f=1} END{exit !f}' && {
    log "$REPO_LABEL already mounted"; return 0; }

  # expose USB storage to host
  /etc/init.d/usbarbitrator status 2>/dev/null | grep -qi running && /etc/init.d/usbarbitrator stop >/dev/null 2>&1 || true
  chkconfig usbarbitrator off
  esxcli storage core adapter rescan --all >/dev/null 2>&1 || true

  # try by label for up to ~60s
  for i in 1 2 3 4 5 6; do
    esxcli storage filesystem mount -l "$REPO_LABEL" >/dev/null 2>&1 || true
    if esxcli storage filesystem list | awk -v L="$REPO_LABEL" '$2==L{f=1} END{exit !f}'; then
      log "$REPO_LABEL mounted"
      return 0
    fi
    sleep 10
  done

  log "failed to mount $REPO_LABEL"
  return 1
}

ensure_net(){
  # NTP/SSH (quality-of-life)
  esxcli system ntp set -s 10.0.20.10
  esxcli system ntp set -e true
  /etc/init.d/ntpd restart
  vim-cmd hostsvc/enable_ssh; vim-cmd hostsvc/start_ssh

  # Use the existing management switch (usually vSwitch0)
  VSW="$(esxcli network vswitch standard list | awk '/^vSwitch/{print $1; exit}')"
  [ -z "$VSW" ] && VSW="vSwitch0"

  # Create/ensure PGs on that switch
  for item in "VLAN10-Users 10" "VLAN15-WiFi 15" "VLAN20-Servers 20" "VLAN30-DMZ 30" "VLAN99-Mgmt 99"; do
    set -- $item
    esxcli network vswitch standard portgroup add -v "$VSW" -p "$1" >/dev/null 2>&1 || true
    esxcli network vswitch standard portgroup set -p "$1" -v "$2" || true
  done
}

vm_exists(){ vim-cmd vmsvc/getallvms | awk '{print $1,$2}' | grep -q " ${VM_NAME}$"; }

create_provisioner_vm(){
  [ -f "$PROV_ISO" ] || { log "Missing ISO: $PROV_ISO"; return 1; }

  mkdir -p "$VM_DIR"
  [ -f "${VM_DIR}/${VM_NAME}.vmdk" ] || vmkfstools -c 30G -d thin "${VM_DIR}/${VM_NAME}.vmdk"

  cat > "${VM_DIR}/${VM_NAME}.vmx" <<EOF
.encoding = "UTF-8"
config.version = "8"
virtualHW.version = "21"
nvram = "${VM_NAME}.nvram"
svga.present = "TRUE"
pciBridge0.present = "TRUE"
pciBridge4.present = "TRUE"
pciBridge4.virtualDev = "pcieRootPort"
pciBridge4.functions = "8"
pciBridge5.present = "TRUE"
pciBridge5.virtualDev = "pcieRootPort"
pciBridge5.functions = "8"
pciBridge6.present = "TRUE"
pciBridge6.virtualDev = "pcieRootPort"
pciBridge6.functions = "8"
pciBridge7.present = "TRUE"
pciBridge7.virtualDev = "pcieRootPort"
pciBridge7.functions = "8"
vmci0.present = "TRUE"
hpet0.present = "TRUE"
floppy0.present = "FALSE"
numvcpus = "2"
memSize = "4096"
bios.bootRetry.delay = "10"
firmware = "efi"
powerType.powerOff = "default"
powerType.suspend = "soft"
powerType.reset = "default"
tools.upgrade.policy = "manual"
sched.cpu.units = "mhz"
sched.cpu.affinity = "all"
sched.cpu.latencySensitivity = "normal"
scsi0.virtualDev = "pvscsi"
scsi0.present = "TRUE"
sata0.present = "TRUE"
svga.autodetect = "TRUE"
scsi0:0.deviceType = "scsi-hardDisk"
scsi0:0.fileName = "${VM_NAME}.vmdk"
sched.scsi0:0.shares = "normal"
sched.scsi0:0.throughputCap = "off"
scsi0:0.present = "TRUE"
ethernet0.virtualDev = "vmxnet3"
ethernet0.networkName = "${PG_MGT}"
ethernet0.addressType = "generated"
ethernet0.wakeOnPcktRcv = "FALSE"
ethernet0.uptCompatibility = "TRUE"
ethernet0.present = "TRUE"
sata0:0.deviceType = "cdrom-image"
sata0:0.fileName = "${PROV_ISO}"
sata0:0.present = "TRUE"
displayName = "${VM_NAME}"
guestOS = "oraclelinux9-64"
chipset.motherboardLayout = "acpi"
toolScripts.afterPowerOn = "TRUE"
toolScripts.afterResume = "TRUE"
toolScripts.beforeSuspend = "TRUE"
toolScripts.beforePowerOff = "TRUE"
tools.syncTime = "FALSE"
sched.cpu.min = "0"
sched.cpu.shares = "normal"
sched.mem.min = "0"
sched.mem.minSize = "0"
sched.mem.shares = "normal"
EOF

  if ! vm_exists; then
    VMID=$(vim-cmd solo/registervm "${VM_DIR}/${VM_NAME}.vmx")
    log "Registered ${VM_NAME} as VMID ${VMID}"
  else
    VMID=$(vim-cmd vmsvc/getallvms | awk -v n="${VM_NAME}" '$0 ~ (" " n "$"){print $1}')
    vim-cmd vmsvc/reload "$VMID" >/dev/null 2>&1 || true
    log "${VM_NAME} already registered as VMID ${VMID}"
  fi

  vim-cmd vmsvc/power.on "$VMID" >/dev/null 2>&1 || true
  log "Created and powered on ${VM_NAME}"
}

# ---------- MAIN ----------
ensure_net
if mount_repo; then
  log "Repo ready at ${REPO_BASE}; creating provisioning VMâ€¦"
  create_provisioner_vm || log "Provisioner creation failed"
else
  log "Repo not available; skipping provisioning VM creation"
fi
# ---------- MAIN END ----------
